<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxel Game Prototype</title>
    <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
    <div id="mainMenu">
        <h1>Voxel Game</h1>
        <button id="startButton">Start Game</button>
    </div>

    <div id="gameContainer" style="display: none;"></div>
    <!-- Pause Menu -->
    <div id="pauseMenu" style="display:none;">
        <!-- Main Pause Screen -->
        <div id="pauseMainScreen" class="pause-screen">
            <h2>Game Paused</h2>
            <button id="resumeButton">Resume Game</button>
            <button id="settingsButton">Settings</button>
        </div>

        <!-- Settings Screen -->
        <div id="pauseSettingsScreen" class="pause-screen" style="display:none;">
            <h2>Settings</h2>
            
            <div class="setting-item">
                <label>Mouse Sensitivity:
                    <input type="range" id="sensitivitySlider" min="0.1" max="2.0" step="0.01" value="1.0">
                    <span id="sensitivityValue">1.0</span>
                </label>
            </div>
            
            <div class="setting-item">
                <label>Debug Mode:
                    <input type="checkbox" id="debugToggle">
                </label>
            </div>
            
            <button id="keybindsButton">Keybinds</button>
            <button id="backToMainButton">Back</button>
        </div>
    </div>

    <script src="js/three.min.js"></script>
    <!--octree-->
    <script>
        class octreeNode {
            constructor(x,y,z,halfsize,material,minsize,isleaf){
                //xyz position relative to world origin(+,+,+ point of cube)
                this.x=x;
                this.y=y;
                this.z=z;
                //length of one side of cube this node describes
                this.halfsize=halfsize;
                //material of voxel
                this.material=material;
                //minimum voxel size(size of singular voxel)
                this.minsize=minsize;
                //children nodes
                this.children=null;
                //is leaf(does octree end on this node)
                this.isleaf=isleaf;
            }

            /**
             * split current node into children nodes
             * @param materials list of materials to set for each child node
             * positions of cubes for materials list(positive or negative xyz for quadrant)
             * 0: - - -
             * 1: + - -
             * 2: - + -
             * 3: + + -
             * 4: - - +
             * 5: + - +
             * 6: - + +
             * 7: + + +
             */
            split(materials) {
                if (this.halfsize*2<=this.minsize){
                    return false;
                }
                this.isleaf=false;
                this.children=new Array(8);
                let newhalf=this.halfsize/2;
                //iterate 8 quadrants and calculate child locations
                for (let i=0;i<8;i++){
                    //fing sign for each axis using bit masks
                    /**
                     * & is bit operator, same as c++
                     * 5&1
                     * 101
                     * 001
                     * ___
                     * 001=1
                     */
                    let signX=(i & 1) ? 1:-1;
                    let signY=(i & 2) ? 1:-1;
                    let signZ=(i & 4) ? 1:-1;
                    let childMaterial=materials[i] ?? this.material;
                    this.children[i]=new octreeNode(this.x+signX*newhalf,this.y+signY*newhalf,this.z+signZ*newhalf,newhalf,childMaterial,this.minsize,true);

                }
            }
            /**
             * merge children nodes into current node
             * @param forRendering if true, merges regardless of material, averaging colors, and doesn't actually apply changes to instance
             * @return if forRendering is true, returns merged node. Otherwise returns nothing.
             */
            merge(forRendering){
                if (this.isleaf){
                    return null;
                }
                if (forRendering){
                    //TODO: implement color averaging
                    let mergednode=new octreeNode(this.x,this.y,this.z,this.halfsize,this.material,this.minsize,true);
                    return mergednode;
                }
                //iterate children and check if materials are same
                let firstmat=this.children[0].material;
                for (let i=1;i<8;i++){
                    if (this.children[i].material!=firstmat){
                        return null;
                    }
                }
                this.material=firstmat;
                this.children=null;
                this.isleaf=true;
            }
            /**
             * get cube instance at position(x,y,z)
             * @param x world x coordinate(relative to origin)
             * @param y world y coordinate(relative to origin)
             * @param z world z coordinate(relative to origin)
             */
            get(x,y,z){
                if (this.isleaf){
                    return this;
                }
                let index=0;
                /**
                 * |= bitwise or assignment
                 * 1|=3
                 * 001
                 * 011
                 * ___
                 * 011=3
                 * 2|=1
                 * 010
                 * 001
                 * ___
                 * 011=3
                 */
                if (x>this.x) index|=1;
                if (y>this.y) index|=2;
                if (z>this.z) index|=4;
                return this.children[index].get(x,y,z);
            }
        }
    </script>
    <!--controls.js-->
    <script>
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let isLocked = false;
        let gameRunning = false;
        let pressedKeys = new Set();
        // Keybinds map - stores all rebindable keys
        let keybinds = {
            forward: 'KeyW',
            backward: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            up: 'Space',
            down: 'ShiftLeft'
        };

        let yawObject, pitchObject;

        /**
         * Initializes first-person camera controls using a yaw → pitch → camera hierarchy.
         * - yawObject rotates around Y (turning left/right).
         * - pitchObject rotates around X (looking up/down).
         * - The camera is a child of pitchObject so both rotations apply naturally.
         *
         * Pointer-lock and keyboard listeners are created here.
         *
         * @param {THREE.Camera} camera - The active scene camera.
         * @param {HTMLElement} domElement - The DOM element receiving pointer-lock.
         * @return {THREE.Object3D} yawObject - Root object containing the full control hierarchy.
         */
        function initControls(camera, domElement) {
            // Create objects for pitch (vertical) and yaw (horizontal)
            yawObject = new THREE.Object3D();
            pitchObject = new THREE.Object3D();

            // Hierarchy: yawObject -> pitchObject -> camera
            yawObject.add(pitchObject);
            pitchObject.add(camera);

            // Pointer lock activation
            domElement.addEventListener("click", () => {
                domElement.requestPointerLock();
            });

            // Check when pointer lock state changes
            document.addEventListener("pointerlockchange", () => {
                isLocked = document.pointerLockElement === domElement;
                // If pointer was unlocked and game is running, show pause menu
                if (!isLocked && gameRunning) {
                    showPauseMenu();
                }
            });

            document.addEventListener("mousemove", (event) => {
                //Don't trigger camera movement if mouse is not locked
                if (!isLocked) return;

                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                yawObject.rotation.y -= movementX * 0.002;
                pitchObject.rotation.x -= movementY * 0.002;

                // Limit vertical look (avoid flipping)
                pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
            });

            // Keyboard input
            document.addEventListener("keydown", (e) => {
                //Get all bindable keys
                const bindableKeys=Object.values(keybinds);

                // Prevent default browser behavior for game keys
                if (bindableKeys.includes(e.code)) {
                    e.preventDefault();
                }
                pressedKeys.add(e.code);
            });

            document.addEventListener("keyup", (e) => {
                pressedKeys.delete(e.code);
            });
            return yawObject; // attach this to the scene
        }

        /**
         * Updates FPS camera movement each frame:
         * - Applies acceleration and damping.
         * - Uses local-space movement (translateX/Z) for proper forward/right motion.
         * - Vertical movement modifies world-space Y.
         *
         * Math notes:
         * - direction vector is normalized so diagonals do not exceed speed
         *   length = sqrt(x² + y² + z²)
         *   normalized = vector / length
         *
         * @param {number} delta - Time step in seconds since last frame.
         * @return {void}
         */
        function updateControls(delta) {
            if (!isLocked) return;

            const speed = 75.0;

            // Apply exponential damping:
            // v -= v * dampingFactor * dt
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= velocity.y * 10.0 * delta;

            // Check pressed keys using the Set
            moveForward = pressedKeys.has('KeyW');
            moveBackward = pressedKeys.has('KeyS');
            moveLeft = pressedKeys.has('KeyA');
            moveRight = pressedKeys.has('KeyD');
            moveUp = pressedKeys.has('Space');
            moveDown = pressedKeys.has('ShiftLeft');

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveLeft) - Number(moveRight);
            direction.y = Number(moveUp) - Number(moveDown);

            // Normalize to avoid faster diagonal movement
            // sqrt(x² + z² + y²) → make length = 1
            direction.normalize();

            //Update velocity(accelerate) on input
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (moveUp || moveDown) velocity.y += direction.y * speed * delta;

            // Apply vertical movement
            yawObject.position.y += velocity.y * delta;

            // Apply horizontal movement relative to camera yaw
            yawObject.translateX(velocity.x * delta);
            yawObject.translateZ(velocity.z * delta);
        }
    </script>
    <!--mainmenu.js-->
    <script>
        /**
         * Handles the transition from the main menu to the game.
         * Hides the menu, shows the game container, initializes the scene,
         * locks pointer, then begins the animation loop.
         */
        document.getElementById("startButton").addEventListener("click", () => {
            document.getElementById("mainMenu").style.display = "none";
            document.getElementById("gameContainer").style.display = "block";
            // document.getElementById("gameContainer").requestPointerLock();

            initScene(); // from init.js
            renderer.domElement.requestPointerLock();
            startGameLoop(); // from main.js
        });
    </script>
    <!--init.js-->
    <script>
        let scene, camera, renderer, cube;

        /**
         * Initializes the Three.js scene:
         * - Creates camera, scene, renderer
         * - Builds ground and test cube
         * - Creates directional light
         * - Injects FPS controls and attaches them to the scene
         *
         * @return {void}
         */
        function initScene() {
            const container = document.getElementById("gameContainer");

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 0);
            // camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Initialize controls
            controlsRoot = initControls(camera, renderer.domElement);
            scene.add(controlsRoot);
            controlsRoot.position.set(0, 1.6, 5);

            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 7.5);
            scene.add(light);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Cube
            const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            cube = new THREE.Mesh(cubeGeo, cubeMat);
            cube.position.y = 0.5;
            scene.add(cube);

            window.addEventListener("resize", onWindowResize);
        }

        /**
         * Adjusts camera and renderer size when the browser window is resized.
         *
         * @return {void}
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>

    <!--main.js-->
    <script>
        /**
         * Starts the game loop using requestAnimationFrame.
         * Computes delta time, updates controls, animates the cube,
         * and renders the scene.
         *
         * @return {void}
         */
        function startGameLoop() {
            let previousTime = performance.now();

            function animate() {
                requestAnimationFrame(animate);

                const currentTime = performance.now();
                const delta = (currentTime - previousTime) / 1000;
                previousTime = currentTime;

                updateControls(delta);

                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

                renderer.render(scene, camera);
            }

            animate();
        }
    </script>
</body>
</html>
