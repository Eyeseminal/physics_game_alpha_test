<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxel Game Prototype</title>
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <div id="mainMenu">
        <h1>Voxel Game</h1>
        <button id="startButton">Start Game</button>
    </div>

    <div id="gameContainer" style="display: none;"></div>

    <!-- Pause Menu -->
    <div id="pauseMenu" style="display:none;">
        <!-- Main Pause Screen -->
        <div id="pauseMainScreen" class="pause-screen">
            <h2>Game Paused</h2>
            <button id="resumeButton">Resume Game</button>
            <button id="settingsButton">Settings</button>
        </div>

        <!-- Settings Screen -->
        <div id="pauseSettingsScreen" class="pause-screen" style="display:none;">
            <h2>Settings</h2>
            <div class="setting-item">
                <label>Mouse Sensitivity:
                    <input type="range" id="sensitivitySlider" min="0.1" max="2.0" step="0.01" value="1.0">
                    <span id="sensitivityValue">1.0</span>
                </label>
            </div>
            <div class="setting-item">
                <label>Debug Mode:
                    <input type="checkbox" id="debugToggle">
                </label>
            </div>
            <button id="keybindsButton">Keybinds</button>
            <button id="backToMainButton">Back</button>
        </div>

        <!-- Keybinds Screen -->
        <div id="pauseKeybindsScreen" class="pause-screen" style="display:none;">
            <h2>Keybinds</h2>

            <div class="keybind-list">
                <div class="keybind-item">
                    <span class="keybind-label">Move Forward:</span>
                    <button class="keybind-button" data-action="forward">W</button>
                </div>
                <div class="keybind-item">
                    <span class="keybind-label">Move Backward:</span>
                    <button class="keybind-button" data-action="backward">S</button>
                </div>
                <div class="keybind-item">
                    <span class="keybind-label">Move Left:</span>
                    <button class="keybind-button" data-action="left">A</button>
                </div>
                <div class="keybind-item">
                    <span class="keybind-label">Move Right:</span>
                    <button class="keybind-button" data-action="right">D</button>
                </div>
                <div class="keybind-item">
                    <span class="keybind-label">Move Up:</span>
                    <button class="keybind-button" data-action="up">Space</button>
                </div>
                <div class="keybind-item">
                    <span class="keybind-label">Move Down:</span>
                    <button class="keybind-button" data-action="down">Shift</button>
                </div>
            </div>

            <button id="backToSettingsButton">Back</button>
        </div>
    </div>

    <script src="js/three.min.js"></script>

    <!-- ============================= -->
    <!--  COMBINED JAVASCRIPT SECTION  -->
    <!-- ============================= -->
    <script>

    /* ============================================================
       1. CLASS DEFINITIONS
       ============================================================ */

    class octreeNode {
        constructor(x,y,z,halfsize,material,minsize,isleaf){
            //xyz position relative to world origin(+,+,+ point of cube)
            this.x=x;
            this.y=y;
            this.z=z;
            //length of one side of cube this node describes
            this.halfsize=halfsize;
            //material of voxel
            this.material=material;
            //minimum voxel size(size of singular voxel)
            this.minsize=minsize;
            //children nodes
            this.children=null;
            //is leaf(does octree end on this node)
            this.isleaf=isleaf;
        }

        /**
         * split current node into children nodes
         * @param materials list of materials to set for each child node
             * positions of cubes for materials list(positive or negative xyz for quadrant)
             * 0: - - -
             * 1: + - -
             * 2: - + -
             * 3: + + -
             * 4: - - +
             * 5: + - +
             * 6: - + +
             * 7: + + +
         */
        split(materials) {
            if (this.halfsize*2<=this.minsize){
                return false;
            }
            this.isleaf=false;
            this.children=new Array(8);
            let newhalf=this.halfsize/2;
                //iterate 8 quadrants and calculate child locations
            for (let i=0;i<8;i++){
                    //fing sign for each axis using bit masks
                    /**
                     * & is bit operator, same as c++
                     * 5&1
                     * 101
                     * 001
                     * ___
                     * 001=1
                     */
                let signX=(i & 1) ? 1:-1;
                let signY=(i & 2) ? 1:-1;
                let signZ=(i & 4) ? 1:-1;
                let childMaterial=materials[i] ?? this.material;
                this.children[i]=new octreeNode(
                    this.x+signX*newhalf,
                    this.y+signY*newhalf,
                    this.z+signZ*newhalf,
                    newhalf,
                    childMaterial,
                    this.minsize,
                    true
                );
            }
        }

        /**
         * merge children nodes into current node
             * @param forRendering if true, merges regardless of material, averaging colors, and doesn't actually apply changes to instance
             * @return if forRendering is true, returns merged node. Otherwise returns nothing.
         */
        merge(forRendering){
            if (this.isleaf){
                return null;
            }
            if (forRendering){
                //TODO: implement color averaging
                let mergednode=new octreeNode(
                    this.x,this.y,this.z,this.halfsize,this.material,this.minsize,true
                );
                return mergednode;
            }
                //iterate children and check if materials are same
            let firstmat=this.children[0].material;
            for (let i=1;i<8;i++){
                if (this.children[i].material!=firstmat){
                    return null;
                }
            }
            this.material=firstmat;
            this.children=null;
            this.isleaf=true;
        }

        /**
         * get cube instance at position(x,y,z)
             * @param x world x coordinate(relative to origin)
             * @param y world y coordinate(relative to origin)
             * @param z world z coordinate(relative to origin)
         */
        get(x,y,z){
            if (this.isleaf){
                return this;
            }
            let index=0;
                /**
                 * |= bitwise or assignment
                 * 1|=3
                 * 001
                 * 011
                 * ___
                 * 011=3
                 * 2|=1
                 * 010
                 * 001
                 * ___
                 * 011=3
                 */
            if (x>this.x) index|=1;
            if (y>this.y) index|=2;
            if (z>this.z) index|=4;
            return this.children[index].get(x,y,z);
        }
    }

    /* ============================================================
       2. FUNCTION DEFINITIONS
       ============================================================ */

    /* ---------- CONTROLS ---------- */
    /**
    * Initializes first-person camera controls using a yaw → pitch → camera hierarchy.
    * - yawObject rotates around Y (turning left/right).
    * - pitchObject rotates around X (looking up/down).
    * - The camera is a child of pitchObject so both rotations apply naturally.
    *
    * Pointer-lock and keyboard listeners are created here.
    *
    * @param {THREE.Camera} camera - The active scene camera.
    * @param {HTMLElement} domElement - The DOM element receiving pointer-lock.
    * @return {THREE.Object3D} yawObject - Root object containing the full control hierarchy.
    */
    function initControls(camera, domElement) {
        // Create objects for pitch (vertical) and yaw (horizontal)
        yawObject = new THREE.Object3D();
        pitchObject = new THREE.Object3D();

        // Hierarchy: yawObject -> pitchObject -> camera
        yawObject.add(pitchObject);
        pitchObject.add(camera);

        // Pointer lock activation
        domElement.addEventListener("click", () => {
            domElement.requestPointerLock();
        });

        // Check when pointer lock state changes
        document.addEventListener("pointerlockchange", () => {
            isLocked = document.pointerLockElement === domElement;
            // If pointer was unlocked and game is running, show pause menu
            if (!isLocked && !isPaused) {
                showPauseMenu();
            }
        });

        document.addEventListener("mousemove", (event) => {
            //Don't trigger camera movement if mouse is not locked/game is paused
            if (!isLocked || isPaused) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            yawObject.rotation.y -= movementX * 0.002 * mouseSensitivity;
            pitchObject.rotation.x -= movementY * 0.002 * mouseSensitivity;

            // Limit vertical look (avoid flipping)
            pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
        });

        // Keyboard input
        document.addEventListener("keydown", (e) => {
            //Get all bindable keys
            const bindableKeys = Object.values(keybinds);
            // Prevent default browser behavior for game keys
            if (bindableKeys.includes(e.code)) {
                e.preventDefault();
            }
            pressedKeys.add(e.code);

            // If we're in listening mode, capture the key
            if (listeningForKey) {
                handleKeybindInput(e);
            }
        });

        document.addEventListener("keyup", (e) => {
            if (listeningForKey) {
                handleKeybindInput(e);
            }
            pressedKeys.delete(e.code);
        });

        return yawObject; // attach this to the scene
    }

    /**
     * Updates FPS camera movement each frame:
     * - Applies acceleration and damping.
     * - Uses local-space movement (translateX/Z) for proper forward/right motion.
     * - Vertical movement modifies world-space Y.
     *
     * Math notes:
     * - direction vector is normalized so diagonals do not exceed speed
     *   length = sqrt(x² + y² + z²)
     *   normalized = vector / length
     *
     * @param {number} delta - Time step in seconds since last frame.
     * @return {void}
     */
    function updateControls(delta) {
        if (!isLocked) return;

        const speed = 75.0;

        // Apply exponential damping:
        // v -= v * dampingFactor * dt
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= velocity.y * 10.0 * delta;

        // Check pressed keys using the keybinds object
        moveForward = pressedKeys.has(keybinds.forward);
        moveBackward = pressedKeys.has(keybinds.backward);
        moveLeft = pressedKeys.has(keybinds.left);
        moveRight = pressedKeys.has(keybinds.right);
        moveUp = pressedKeys.has(keybinds.up);
        moveDown = pressedKeys.has(keybinds.down);

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveLeft) - Number(moveRight);
        direction.y = Number(moveUp) - Number(moveDown);

        // Normalize to avoid faster diagonal movement
        // sqrt(x² + z² + y²) → make length = 1
        direction.normalize();

        //Update velocity(accelerate) on input
        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
        if (moveUp || moveDown) velocity.y += direction.y * speed * delta;

        // Apply vertical movement
        yawObject.position.y += velocity.y * delta;

        // Apply horizontal movement relative to camera yaw
        yawObject.translateX(velocity.x * delta);
        yawObject.translateZ(velocity.z * delta);
    }

    /* ---------- KEYBIND MENU ---------- */

    /**
    * Converts key codes to human-readable names
    * @param {string} code - The event.code from keyboard event
    * @return {string} - Readable key name
    */
    function getKeyDisplayName(code) {
        // Special keys mapping
        const specialKeys = {
            'Space': 'Space',
            'ShiftLeft': 'Left Shift',
            'ShiftRight': 'Right Shift',
            'ControlLeft': 'Left Ctrl',
            'ControlRight': 'Right Ctrl',
            'AltLeft': 'Left Alt',
            'AltRight': 'Right Alt',
            'MetaLeft': 'Left Cmd/Win',
            'MetaRight': 'Right Cmd/Win',
            'Enter': 'Enter',
            'Escape': 'Escape',
            'Backspace': 'Backspace',
            'Tab': 'Tab',
            'CapsLock': 'Caps Lock',
            'ArrowUp': '↑',
            'ArrowDown': '↓',
            'ArrowLeft': '←',
            'ArrowRight': '→'
        };
        // Check if it's a special key
        if (specialKeys[code]) return specialKeys[code];
        // Handle letter keys (KeyA -> A)
        if (code.startsWith('Key')) return code.replace('Key', '');
        // Handle digit keys (Digit1 -> 1)
        if (code.startsWith('Digit')) return code.replace('Digit', '');
        // Handle F-keys (F1, F2, etc.)
        if (code.startsWith('F') && code.length <= 3) return code;
        // Default: return the code as-is
        return code;
    }


    /**
    * Updates all keybind buttons to show current key bindings
    */
    function updateKeybindButtons() {
        const buttons = document.querySelectorAll('.keybind-button');
        buttons.forEach(button => {
            const action = button.getAttribute('data-action');
            const keyCode = keybinds[action];
            button.textContent = getKeyDisplayName(keyCode);

            // Check if this key is used by multiple actions
            const actionsWithKey = getActionsForKey(keyCode);
            // This is a duplicate - add visual indicator
            if (actionsWithKey.length > 1) button.classList.add('duplicate');
            // Not a duplicate - remove indicator if it was there
            else button.classList.remove('duplicate');
        });
    }


    /**
     * Finds all actions that share the same keybind
     * @param {string} keyCode - The key code to check for duplicates
     * @return {Array} - Array of action names that use this key
     */
    function getActionsForKey(keyCode) {
        const actions = [];
        for (let [action, key] of Object.entries(keybinds)) {
            if (key === keyCode) actions.push(action);
        }
        return actions;
    }


    /**
     * Starts listening for a key press to rebind an action
     * @param {string} action - The action to rebind (forward, backward, etc.)
     * @param {HTMLElement} button - The button element that was clicked
     */
    function startListeningForKey(action, button) {
        if (listeningForKey) {
            const oldButton = document.querySelector('.keybind-button.listening');
            if (oldButton) {
                oldButton.classList.remove('listening');
                oldButton.textContent = getKeyDisplayName(keybinds[listeningForKey]);
            }
        }
        // Set this button to listening state
        listeningForKey = action;
        button.classList.add('listening');
        button.textContent = 'Press any key...';
    }


    /**
     * Handles key press while in keybind listening mode
     * @param {KeyboardEvent} e - The keyboard event
     */
    function handleKeybindInput(e) {
        // Only process if we're listening for a key
        if (!listeningForKey) return;

        e.preventDefault();
        e.stopPropagation();

        const newKey = e.code;
        const action = listeningForKey;

        // Don't allow Escape (used for pause menu)
        if (newKey === 'Escape') {
            alert("Cannot bind Escape key – reserved for pause menu.");
            cancelListening();
            return;
        }

        // Check if this key is already bound to another action
        let conflicts = [];
        for (let [otherAction, keyCode] of Object.entries(keybinds)) {
            if (keyCode === newKey && otherAction !== action) {
                conflicts.push(otherAction);
            }
        }

        if (conflicts.length > 0) {
            const list = conflicts.join(', ');
            const ok = window.confirm(
                `${getKeyDisplayName(newKey)} is already bound to: ${list}\n` +
                `Bind it to ${action} also?`
            );
            if (!ok) {
                // Cancel the rebind
                cancelListening();
                return;
            }
        }

        // Assign the new key
        keybinds[action] = newKey;

        // Update the button
        const button = document.querySelector(`.keybind-button[data-action="${action}"]`);
        button.classList.remove('listening');
        button.textContent = getKeyDisplayName(newKey);

        listeningForKey = null;
    }

    /**
     * Cancels key listening and restores button state
     */
    function cancelListening() {
        if (!listeningForKey) return;

        const button = document.querySelector(
            `.keybind-button[data-action="${listeningForKey}"]`
        );
        if (button) {
            button.classList.remove('listening');
            button.textContent = getKeyDisplayName(keybinds[listeningForKey]);
        }

        listeningForKey = null;
    }

    /* ---------- PAUSE MENU ---------- */

    /**
     * Shows the pause menu and displays the main pause screen
     */
    function showPauseMenu() {
        isPaused = true;
            
        // Show overlay
        document.getElementById("pauseMenu").style.display = "flex";

        // Show main screen, hide settings
        document.getElementById("pauseMainScreen").style.display = "flex";
        document.getElementById("pauseSettingsScreen").style.display = "none";
    }

    /**
     * Hides the pause menu and resumes the game
     */
    function resumeGame() {
        isPaused = false;
            
        // Hide pause menu
        document.getElementById("pauseMenu").style.display = "none";

        // Try to lock pointer, with retry if it fails
        function tryLock(attempts = 0) {
            if (attempts > 25) return; // Give up after ~1250ms
            renderer.domElement.requestPointerLock();
            // If not locked after 50ms, try again
            setTimeout(() => {
                if (!isLocked) tryLock(attempts + 1);
            }, 50);
        }

        setTimeout(() => tryLock(), 50);
    }

    /**
     * Navigate to settings screen
     */
    function showSettings() {
        document.getElementById("pauseMainScreen").style.display = "none";
        document.getElementById("pauseSettingsScreen").style.display = "flex";
    }

    /**
    * Navigate back to main pause screen
    */
    function backToMain() {
        document.getElementById("pauseSettingsScreen").style.display = "none";
        document.getElementById("pauseMainScreen").style.display = "flex";
    }

    /**
    * Navigate to keybinds screen
    */
    function showKeybinds() {
        document.getElementById("pauseSettingsScreen").style.display = "none";
        document.getElementById("pauseKeybindsScreen").style.display = "flex";
        updateKeybindButtons(); // Update button text to show current keys
    }

    /**
    * Navigate back to settings from keybinds
    */
    function backToSettings() {
        document.getElementById("pauseKeybindsScreen").style.display = "none";
        document.getElementById("pauseSettingsScreen").style.display = "flex";
    }

    /* ---------- SCENE INITIALIZATION ---------- */

    function initScene() {
        const container = document.getElementById("gameContainer");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        controlsRoot = initControls(camera, renderer.domElement);
        scene.add(controlsRoot);
        controlsRoot.position.set(0, 1.6, 5);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        light.castShadow = true;
        scene.add(light);

        const groundGeo = new THREE.PlaneGeometry(20, 20);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.receiveShadow = true;
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
        const cubeMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        cube = new THREE.Mesh(cubeGeo, cubeMat);
        cube.position.y = 0.5;
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        window.addEventListener("resize", onWindowResize);
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* ---------- GAME LOOP ---------- */

    function startGameLoop() {
        let previousTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused) return;

            const currentTime = performance.now();
            const delta = (currentTime - previousTime) / 1000;
            previousTime = currentTime;

            updateControls(delta);

            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;

            renderer.render(scene, camera);
        }

        animate();
    }

    /* ============================================================
       3. GLOBAL VARIABLE DECLARATIONS (COLLECTED)
       ============================================================ */

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUp = false;
    let moveDown = false;

    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let isLocked = false;
    let pressedKeys = new Set();

    // Keybinds map - stores all rebindable keys
    let keybinds = {
        forward: 'KeyW',
        backward: 'KeyS',
        left: 'KeyA',
        right: 'KeyD',
        up: 'Space',
        down: 'ShiftLeft'
    };

    let yawObject, pitchObject;
    let isPaused = false;
    let mouseSensitivity = 1.0;
    let debugMode = false;
    let listeningForKey = null;

    let scene, camera, renderer, cube, controlsRoot;

    /* ============================================================
       4. RUNTIME CODE (EVENT LISTENERS)
       ============================================================ */

    // Main menu → start game
    document.getElementById("startButton").addEventListener("click", () => {
        document.getElementById("mainMenu").style.display = "none";
        document.getElementById("gameContainer").style.display = "block";
        initScene();
        renderer.domElement.requestPointerLock();
        startGameLoop();
    });

    // Pause menu buttons
    document.getElementById("resumeButton").addEventListener("click", resumeGame);
    document.getElementById("settingsButton").addEventListener("click", showSettings);
    document.getElementById("backToMainButton").addEventListener("click", backToMain);
    document.getElementById("keybindsButton").addEventListener("click", showKeybinds);
    document.getElementById("backToSettingsButton").addEventListener("click", backToSettings);

    // Sensitivity slider
    const sensitivitySlider = document.getElementById("sensitivitySlider");
    const sensitivityValue = document.getElementById("sensitivityValue");

    sensitivitySlider.addEventListener("input", (e) => {
        mouseSensitivity = parseFloat(e.target.value);
        sensitivityValue.textContent = mouseSensitivity.toFixed(2);
    });

    // Debug toggle
    document.getElementById("debugToggle").addEventListener("change", (e) => {
        debugMode = e.target.checked;
        console.log("Debug mode:", debugMode);
    });

    // Keybind button listeners
    document.addEventListener('DOMContentLoaded', () => {
        const keybindButtons = document.querySelectorAll('.keybind-button');
        keybindButtons.forEach(button => {
            button.addEventListener('click', () => {
                const action = button.getAttribute('data-action');
                startListeningForKey(action, button);
            });
        });
    });

    // Global keybind capture
    document.addEventListener('keydown', (e) => {
        if (listeningForKey) handleKeybindInput(e);
    });

    </script>
</body>
</html>